class GameConfig { static CANVAS = { WIDTH: 400, HEIGHT: 200 }; static GAMEPLAY = { SPEED_PX_PER_SEC: 170, TARGET_ZONE_X: 200, BEAT_TOLERANCE: 15, BEATS_TO_WIN: 10, START_BPM: 60, BPM_INCREMENT_PER_BEAT: 6, MIN_BEAT_DISTANCE: 60, INITIAL_BEAT_OFFSET: 600, IS_GAME_REPEATABLE: !1, BREATHING_FREQ: .005, BREATHING_AMP: 35, PVC_CHANCE: .22, PVC_EARLY_FACTOR: .55 }; static AUDIO = { BEAT_FREQ: 880, BEAT_DURATION: .15, BEAT_VOLUME: .3, SHOCK_FREQ_START: 100, SHOCK_FREQ_END: 50, SHOCK_DURATION: .2, SHOCK_VOLUME: .5, FLATLINE_FREQ: 600, FLATLINE_VOLUME: .1, SUCCESS_FREQ_1: 523.25, SUCCESS_FREQ_2: 659.25, SUCCESS_DURATION: .4, SUCCESS_VOLUME: .2 }; static VISUAL = { GRID_SIZE: 40, QRS_WIDTH: 50, Q_WAVE_START: -15, Q_WAVE_END: -5, Q_WAVE_HEIGHT: 10, R_WAVE_START: -5, R_WAVE_END: 5, R_WAVE_HEIGHT: 70, S_WAVE_START: 5, S_WAVE_END: 15, S_WAVE_HEIGHT: 20, T_WAVE_START: 25, T_WAVE_END: 45, T_WAVE_HEIGHT: 15, NOISE_AMPLITUDE: 4, SHOW_TARGET_ZONE_HIGHLIGHT: !1 }; static COLORS = { BACKGROUND: "#000", GRID: "#222", EKG_ALIVE: "#00ff00", EKG_DEAD: "#ff0000", TARGET_ZONE_ACTIVE: "rgba(0, 255, 0, 0.3)", TARGET_ZONE_INACTIVE: "rgba(255, 255, 255, 0.1)", TARGET_LINE: "rgba(255, 255, 255, 0.5)" } } class AudioEngine { constructor() { this.ctx = new (window.AudioContext || window.webkitAudioContext), this.flatlineOscillator = null } _ensureContext() { "suspended" === this.ctx.state && this.ctx.resume().catch((e => console.warn("Audio resume failed:", e))) } playBeat() { try { this._ensureContext(); const e = this.ctx.createOscillator(), t = this.ctx.createGain(); e.connect(t), t.connect(this.ctx.destination), e.type = "sine", e.frequency.setValueAtTime(GameConfig.AUDIO.BEAT_FREQ, this.ctx.currentTime), e.frequency.exponentialRampToValueAtTime(.01, this.ctx.currentTime + GameConfig.AUDIO.BEAT_DURATION), t.gain.setValueAtTime(GameConfig.AUDIO.BEAT_VOLUME, this.ctx.currentTime), t.gain.exponentialRampToValueAtTime(.01, this.ctx.currentTime + .67 * GameConfig.AUDIO.BEAT_DURATION), e.start(), e.stop(this.ctx.currentTime + GameConfig.AUDIO.BEAT_DURATION) } catch (e) { console.warn("Beat sound failed:", e) } } playShock() { try { this._ensureContext(); const e = this.ctx.createOscillator(), t = this.ctx.createGain(); e.connect(t), t.connect(this.ctx.destination), e.type = "sawtooth", e.frequency.setValueAtTime(GameConfig.AUDIO.SHOCK_FREQ_START, this.ctx.currentTime), e.frequency.linearRampToValueAtTime(GameConfig.AUDIO.SHOCK_FREQ_END, this.ctx.currentTime + GameConfig.AUDIO.SHOCK_DURATION), t.gain.setValueAtTime(GameConfig.AUDIO.SHOCK_VOLUME, this.ctx.currentTime), t.gain.linearRampToValueAtTime(0, this.ctx.currentTime + GameConfig.AUDIO.SHOCK_DURATION), e.start(), e.stop(this.ctx.currentTime + GameConfig.AUDIO.SHOCK_DURATION) } catch (e) { console.warn("Shock sound failed:", e) } } startFlatline() { if (!this.flatlineOscillator) try { this._ensureContext(); const e = this.ctx.createOscillator(), t = this.ctx.createGain(); e.connect(t), t.connect(this.ctx.destination), e.type = "square", e.frequency.setValueAtTime(GameConfig.AUDIO.FLATLINE_FREQ, this.ctx.currentTime), t.gain.setValueAtTime(GameConfig.AUDIO.FLATLINE_VOLUME, this.ctx.currentTime), e.start(), this.flatlineOscillator = { osc: e, gain: t } } catch (e) { console.warn("Flatline sound failed:", e) } } stopFlatline() { if (this.flatlineOscillator) try { this.flatlineOscillator.gain.gain.setTargetAtTime(0, this.ctx.currentTime, .1), this.flatlineOscillator.osc.stop(this.ctx.currentTime + .1) } catch (e) { console.warn("Stop flatline failed:", e) } finally { this.flatlineOscillator = null } } playSuccess() { try { this._ensureContext(); const e = this.ctx.createOscillator(), t = this.ctx.createGain(); e.connect(t), t.connect(this.ctx.destination), e.type = "sine", e.frequency.setValueAtTime(GameConfig.AUDIO.SUCCESS_FREQ_1, this.ctx.currentTime), e.frequency.setValueAtTime(GameConfig.AUDIO.SUCCESS_FREQ_2, this.ctx.currentTime + .1), t.gain.setValueAtTime(GameConfig.AUDIO.SUCCESS_VOLUME, this.ctx.currentTime), t.gain.linearRampToValueAtTime(0, this.ctx.currentTime + GameConfig.AUDIO.SUCCESS_DURATION), e.start(), e.stop(this.ctx.currentTime + GameConfig.AUDIO.SUCCESS_DURATION) } catch (e) { console.warn("Success sound failed:", e) } } cleanup() { this.stopFlatline() } } class Beat { constructor(e) { this.x = e, this.hit = !1, this.processed = !1 } isOffscreen(e) { return this.x - e < -100 } getScreenX(e) { return this.x - e } isInTargetZone(e) { const t = this.getScreenX(e); return Math.abs(t - GameConfig.GAMEPLAY.TARGET_ZONE_X) < GameConfig.GAMEPLAY.BEAT_TOLERANCE } canHit() { return !this.hit && !this.processed } markHit() { this.hit = !0, this.processed = !0 } markMissed() { this.processed = !0 } } class GameState { constructor() { this.reset() } reset() { this.isRunning = !1, this.isDead = !1, this.isWon = !1, this.score = 0, this.bpm = GameConfig.GAMEPLAY.START_BPM, this.totalDistanceTraveled = 0, this.beats = [], this.nextBeatAbsolutePos = GameConfig.GAMEPLAY.INITIAL_BEAT_OFFSET, this.lastFrameTime = performance.now() } start() { this.reset(), this.isRunning = !0, this.lastFrameTime = performance.now() } stop() { this.isRunning = !1 } die() { this.isDead = !0, this.isRunning = !1 } win() { this.isWon = !0, this.isRunning = !1 } addBeat() { this.beats.push(new Beat(this.nextBeatAbsolutePos)); let e = GameConfig.GAMEPLAY.START_BPM + this.score * GameConfig.GAMEPLAY.BPM_INCREMENT_PER_BEAT; e += Math.sin(this.totalDistanceTraveled * GameConfig.GAMEPLAY.BREATHING_FREQ) * GameConfig.GAMEPLAY.BREATHING_AMP; const t = .98 + .04 * Math.random(); let s = 60 * GameConfig.GAMEPLAY.SPEED_PX_PER_SEC / (e * t); this.score > 2 && Math.random() < GameConfig.GAMEPLAY.PVC_CHANCE && (s *= GameConfig.GAMEPLAY.PVC_EARLY_FACTOR), s = Math.max(s, GameConfig.GAMEPLAY.MIN_BEAT_DISTANCE), this.nextBeatAbsolutePos += s, this.bpm = Math.floor(e) } incrementScore() { this.score++, this.score >= GameConfig.GAMEPLAY.BEATS_TO_WIN && this.win() } cleanupOffscreenBeats() { this.beats = this.beats.filter((e => !e.isOffscreen(this.totalDistanceTraveled))) } getScreenRightEdge() { return this.totalDistanceTraveled + GameConfig.CANVAS.WIDTH } hasActiveBeatsInZone() { return this.beats.some((e => e.isInTargetZone(this.totalDistanceTraveled) && e.canHit())) } } class EKGRenderer { constructor(e) { this.canvas = e, this.ctx = e.getContext("2d") } reset() { } _getWaveformY(e, t) { let s = GameConfig.CANVAS.HEIGHT / 2; t.beats.forEach((t => { const i = e - t.x; Math.abs(i) < GameConfig.VISUAL.QRS_WIDTH && (i > GameConfig.VISUAL.Q_WAVE_START && i < GameConfig.VISUAL.Q_WAVE_END ? s += GameConfig.VISUAL.Q_WAVE_HEIGHT : i >= GameConfig.VISUAL.R_WAVE_START && i < GameConfig.VISUAL.R_WAVE_END ? s -= GameConfig.VISUAL.R_WAVE_HEIGHT : i >= GameConfig.VISUAL.S_WAVE_START && i < GameConfig.VISUAL.S_WAVE_END ? s += GameConfig.VISUAL.S_WAVE_HEIGHT : i > GameConfig.VISUAL.T_WAVE_START && i < GameConfig.VISUAL.T_WAVE_END && (s -= GameConfig.VISUAL.T_WAVE_HEIGHT)) })); const i = (Math.sin(.5 * e) + Math.sin(.23 * e)) * (GameConfig.VISUAL.NOISE_AMPLITUDE / 2); return s += i, s } draw(e) { const { ctx: t, canvas: s } = this; t.fillStyle = GameConfig.COLORS.BACKGROUND, t.fillRect(0, 0, s.width, s.height), this._drawGrid(e), this._drawTargetZone(e), this._drawWaveform(e) } _drawGrid(e) { const { ctx: t, canvas: s } = this; t.strokeStyle = GameConfig.COLORS.GRID, t.lineWidth = 1, t.beginPath(); for (let i = -(e.totalDistanceTraveled % GameConfig.VISUAL.GRID_SIZE); i < s.width; i += GameConfig.VISUAL.GRID_SIZE)t.moveTo(i, 0), t.lineTo(i, s.height); for (let e = 0; e < s.height; e += GameConfig.VISUAL.GRID_SIZE)t.moveTo(0, e), t.lineTo(s.width, e); t.stroke() } _drawTargetZone(e) { const { ctx: t, canvas: s } = this, { TARGET_ZONE_X: i, BEAT_TOLERANCE: n } = GameConfig.GAMEPLAY; if (GameConfig.VISUAL.SHOW_TARGET_ZONE_HIGHLIGHT) { const a = e.hasActiveBeatsInZone(); t.fillStyle = a ? GameConfig.COLORS.TARGET_ZONE_ACTIVE : GameConfig.COLORS.TARGET_ZONE_INACTIVE, t.fillRect(i - n, 0, 2 * n, s.height) } t.strokeStyle = GameConfig.COLORS.TARGET_LINE, t.lineWidth = 2, t.beginPath(), t.moveTo(i, 0), t.lineTo(i, s.height), t.stroke() } _drawWaveform(e) { const { ctx: t } = this; t.strokeStyle = e.isDead ? GameConfig.COLORS.EKG_DEAD : GameConfig.COLORS.EKG_ALIVE, t.lineWidth = 2, t.lineJoin = "round", t.shadowBlur = 4, t.shadowColor = t.strokeStyle, t.beginPath(); for (let s = 0; s <= GameConfig.CANVAS.WIDTH; s++) { const i = e.totalDistanceTraveled + s, n = this._getWaveformY(i, e); 0 === s ? t.moveTo(s, n) : t.lineTo(s, n) } t.stroke(), t.shadowBlur = 0 } drawFlatline() { const { ctx: e, canvas: t } = this; e.strokeStyle = GameConfig.COLORS.EKG_DEAD, e.lineWidth = 2, e.shadowBlur = 4, e.shadowColor = GameConfig.COLORS.EKG_DEAD, e.beginPath(), e.moveTo(0, t.height / 2), e.lineTo(t.width, t.height / 2), e.stroke(), e.shadowBlur = 0 } } class InputHandler { constructor(e) { this.onInput = e, this.lastInputTime = 0, this.debounceDelay = 100, this.isKeyPressed = !1 } handleClick(e) { e.preventDefault(), this._triggerInput() } handleKeyDown(e) { "Space" === e.code && (e.preventDefault(), this.isKeyPressed || (this.isKeyPressed = !0, this._triggerInput())) } handleKeyUp(e) { "Space" === e.code && (this.isKeyPressed = !1) } _triggerInput() { const e = performance.now(); e - this.lastInputTime < this.debounceDelay || (this.lastInputTime = e, this.onInput()) } } class GameController { constructor() { this._initializeDOM(), this.audio = new AudioEngine, this.state = new GameState, this.renderer = new EKGRenderer(this.elements.canvas), this.input = new InputHandler((() => this.handleInput())), this._setupEventListeners(), this.animationFrameId = null } _initializeDOM() { this.elements = { widget: document.getElementById("captchaWidget"), clickTarget: document.getElementById("captchaClickTarget"), spinner: document.getElementById("mainSpinner"), checkboxIcon: document.getElementById("checkboxIcon"), overlay: document.getElementById("modalOverlay"), box: document.getElementById("challengeBox"), canvas: document.getElementById("ecgCanvas"), shockBtn: document.getElementById("shockBtn"), visualHeart: document.getElementById("visualHeart"), statusMsg: document.getElementById("gameStatus"), bpmDisplay: document.getElementById("bpmDisplay"), deadMsg: document.getElementById("deadMsg"), restartHint: document.getElementById("restartHint"), verifyBtn: document.getElementById("verifyBtn") } } _setupEventListeners() { this.elements.clickTarget.addEventListener("click", (() => this.openChallenge())), this.elements.shockBtn.addEventListener("mousedown", (e => this.input.handleClick(e))), document.addEventListener("keydown", (e => { "none" !== this.elements.overlay.style.display && (this.input.handleKeyDown(e), "Space" === e.code && (this.elements.shockBtn.style.transform = "translateY(4px)", this.elements.shockBtn.style.boxShadow = "none")) })), document.addEventListener("keyup", (e => { "Space" === e.code && (this.input.handleKeyUp(e), this.elements.shockBtn.style.transform = "translateY(0)", this.elements.shockBtn.style.boxShadow = "") })), this.elements.verifyBtn.addEventListener("click", (() => this.completeVerification())), this.elements.overlay.addEventListener("click", (e => { e.target === this.elements.overlay && (this.elements.box.classList.add("shake"), setTimeout((() => this.elements.box.classList.remove("shake")), 500)) })) } openChallenge() { this.elements.clickTarget.style.opacity = "0", this.elements.spinner.style.display = "block", setTimeout((() => { this.elements.overlay.style.display = "flex", this.elements.overlay.offsetWidth, this.elements.overlay.style.background = "rgba(0,0,0,0.6)", this.elements.box.style.opacity = "1", this.elements.box.style.transform = "scale(1)", this.startGame() }), 1e3) } startGame() { this.animationFrameId && cancelAnimationFrame(this.animationFrameId), this.audio.cleanup(), this.state.start(), this.renderer.reset(), this.elements.deadMsg.style.display = "none", this.elements.verifyBtn.classList.remove("active"), this.elements.verifyBtn.innerText = "VERIFY", this.elements.shockBtn.disabled = !1, this.elements.shockBtn.style.background = "#d93025", this.elements.shockBtn.innerText = "⚡ DEFIBRILLATE (SPACE)", this.elements.statusMsg.style.color = "#0f0", this.updateUI(), this.animationFrameId = requestAnimationFrame((e => this.gameLoop(e))) } gameLoop(e) { if (!this.state.isRunning) return; const t = (e - this.state.lastFrameTime) / 1e3; this.state.lastFrameTime = e; const s = GameConfig.GAMEPLAY.SPEED_PX_PER_SEC * t; for (this.state.totalDistanceTraveled += s; this.state.nextBeatAbsolutePos < this.state.getScreenRightEdge();)this.state.addBeat(); this.state.beats.forEach((e => { if (e.canHit()) { e.getScreenX(this.state.totalDistanceTraveled) < GameConfig.GAMEPLAY.TARGET_ZONE_X - GameConfig.GAMEPLAY.BEAT_TOLERANCE && (e.markMissed(), this.failGame("ASYSTOLE DETECTED - MISSED BEAT")) } })), this.state.cleanupOffscreenBeats(), this.renderer.draw(this.state), this.updateUI(), this.animationFrameId = requestAnimationFrame((e => this.gameLoop(e))) } handleInput() { if (this.state.isDead) return void (GameConfig.GAMEPLAY.IS_GAME_REPEATABLE && this.startGame()); if (!this.state.isRunning) return; this.audio.playShock(); let e = !1; this.state.beats.forEach((t => { t.canHit() && t.isInTargetZone(this.state.totalDistanceTraveled) && (t.markHit(), e = !0, this.audio.playBeat(), this.elements.visualHeart.classList.add("beat"), setTimeout((() => this.elements.visualHeart.classList.remove("beat")), 150), this.state.incrementScore(), this.state.isWon && this.winGame()) })), e || this.failGame("VFIB TRIGGERED - POOR TIMING") } failGame(e) { this.state.die(), this.animationFrameId && cancelAnimationFrame(this.animationFrameId), this.audio.startFlatline(), this.elements.statusMsg.innerText = e, this.elements.statusMsg.style.color = "red", this.elements.deadMsg.style.display = "block", this.elements.box.classList.add("shake"), setTimeout((() => this.elements.box.classList.remove("shake")), 500), this.renderer.drawFlatline(), GameConfig.GAMEPLAY.IS_GAME_REPEATABLE ? this.elements.restartHint && (this.elements.restartHint.style.display = "block") : (this.elements.restartHint && (this.elements.restartHint.style.display = "none"), this.elements.shockBtn.disabled = !0, this.elements.shockBtn.style.background = "#555", this.elements.shockBtn.innerText = "CRITICAL FAILURE", setTimeout((() => { this.terminateVerification() }), 2e3)) } terminateVerification() { this.audio.cleanup(), this.elements.overlay.style.opacity = "0", setTimeout((() => { this.elements.overlay.style.display = "none", this.elements.spinner.style.display = "none", this.elements.clickTarget.style.opacity = "1", this.elements.checkboxIcon.style.border = "none", this.elements.checkboxIcon.innerHTML = '<span style="color:#d93025; font-size: 28px; font-weight: bold;">✕</span>'; const e = this.elements.clickTarget.querySelector(".label"); e && (e.innerText = "Verification failed", e.style.color = "#d93025"), this.elements.clickTarget.style.pointerEvents = "none", this.elements.widget.style.borderColor = "#d93025", this.elements.widget.style.background = "#fce8e6" }), 300) } winGame() { this.state.win(), this.animationFrameId && cancelAnimationFrame(this.animationFrameId), this.audio.playSuccess(), this.elements.statusMsg.innerText = "RHYTHM ESTABLISHED.", this.elements.statusMsg.style.color = "#1a73e8", this.elements.verifyBtn.classList.add("active"), this.elements.shockBtn.disabled = !0, this.elements.shockBtn.innerText = "PATIENT STABILIZED", this.elements.shockBtn.style.background = "#ccc", this.elements.shockBtn.style.boxShadow = "none", setTimeout((() => this.completeVerification()), 2e3) } updateUI() { this.state.isDead || (this.elements.statusMsg.innerText = `RHYTHM STABLE: ${this.state.score}/${GameConfig.GAMEPLAY.BEATS_TO_WIN}`, this.elements.bpmDisplay.innerText = `${this.state.bpm} BPM`) } completeVerification() { this.elements.overlay.style.opacity = "0", setTimeout((() => { this.elements.overlay.style.display = "none", this.elements.spinner.style.display = "none", this.elements.clickTarget.style.opacity = "1", this.elements.checkboxIcon.style.border = "none", this.elements.checkboxIcon.innerHTML = '<span style="color:green; font-size: 28px;">✔</span>', setTimeout((() => { alert("Verification Complete.\n\nthat now makes you owe me $420,000.") }), 500) }), 300) } } document.addEventListener("DOMContentLoaded", (() => { new GameController }));